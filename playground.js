const { PrintMinNumber } = require('./数据结构与算法/数理.js')
// const { FindPaths } = require('./数据结构与算法/二叉树.js')
function ll() {
  console.log(...arguments)
}

// var demo = { val: 1,
//   left: 
//   { val: 2,
//     left: { val: 3, left: null, right: null },
//     right: { val: 4, left: {
//       val: 5
//     }, right: null } } ,
//   right:
//    { val: 6,
//      left: { val: 7, left: null, right: null },
//      right: { val: 8, left: {
//        val: 9
//      }, right: null } } 
// }

function find() {
  //找到起始字符的位置，返回坐标们
}

// 生成一个记录坐标的记录器（闭包）

// 一个比较坐标是否想等的函数

// 查找上下左右坐标的函数，同样返回坐标们

// 核心问题在于，如果找一半才发现不对，如何去回到上一个节点

// 字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，
// 但是与"aa.a"和"ab*a"均不匹配

var reg = /.*/g

console.log('adnfds'.match(reg))


